{
  "data_source": "kodcode",
  "model_code": "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size + 1))  # Cities are 1-based\n        self.rank = [0] * (size + 1)\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return False  # Already connected\n        if self.rank[x_root] < self.rank[y_root]:\n            self.parent[x_root] = y_root\n        else:\n            self.parent[y_root] = x_root\n            if self.rank[x_root] == self.rank[y_root]:\n                self.rank[x_root] += 1\n        return True\n\ndef find_mst_and_second_best(n: int, m: int, edges: List[Tuple[int, int, int]]):\n    if m == 0:\n        return (0, float('inf'))\n    \n    # Sort edges by weight\n    edges_sorted = sorted(edges, key=lambda x: x[2])\n    \n    # Kruskal's algorithm to find MST\n    uf = UnionFind(n)\n    mst_edges = []\n    total_mst = 0\n    \n    for edge in edges_sorted:\n        u, v, t = edge\n        if uf.union(u, v):\n            mst_edges.append((u, v, t))\n            total_mst += t\n            # Check if all cities are connected\n            if uf.find(1) == uf.find(n):\n                break\n    \n    # Now find the Second-Most MST\n    second_mst = None\n    largest_edge_in_mst = -1\n    for edge in reversed(mst_edges):\n        u, v, t = edge\n        if t > largest_edge_in_mst:\n            largest_edge_in_mst = t\n    \n    # Try removing each edge in descending order of weight\n    for edge in mst_edges:\n        if edge[2] == largest_edge_in_mst:\n            continue\n        u, v, t = edge\n        if uf.union(u, v):\n            if uf.find(1) == uf.find(n):\n                second_mst = total_mst - t\n                break\n        else:\n            # Check if the graph remains connected without this edge\n            if uf.find(1) == uf.find(n):\n                second_mst = total_mst - t\n                break\n    \n    if second_mst is None:\n        return (total_mst, float('inf'))\n    else:\n        return (total_mst, second_mst)",
  "tests": "def test_find_mst_and_second_best():\n    # Sample Test Case 1\n    assert find_mst_and_second_best(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 3), (2, 4, 2), (3, 4, 5)]) == (6, 7)\n    \n    # Additional Test Cases\n    assert find_mst_and_second_best(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) == (3, 4)\n    assert find_mst_and_second_best(2, 1, [(1, 2, 1)]) == (1, float('inf')) # There's no second best network possible.\n    \n    # Larger Test Case\n    n = 6\n    edges = [\n        (1, 2, 6), (1, 3, 1), (1, 4, 5), (2, 3, 5), (2, 5, 3), \n        (3, 4, 5), (3, 5, 6), (3, 6, 4), (4, 6, 2), (5, 6, 6)\n    ]\n    assert find_mst_and_second_best(n, len(edges), edges) == (15, 16)"
}