{
  "data_source": "kodcode",
  "model_code": "class UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size + 1))  # Assuming nodes are 1-based\n        self.rank = [0] * (size + 1)\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return False\n        if self.rank[x_root] < self.rank[y_root]:\n            self.parent[x_root] = y_root\n        else:\n            self.parent[y_root] = x_root\n            if self.rank[x_root] == self.rank[y_root]:\n                self.rank[x_root] += 1\n        return True\n\ndef find_mst(edges, n):\n    edges_sorted = sorted(edges, key=lambda x: x[2])\n    uf = UnionFind(n)\n    mst_edges = []\n    for u, v, t in edges_sorted:\n        if uf.union(u, v):\n            mst_edges.append((u, v, t))\n    return mst_edges\n\ndef find_second_best(mst_edges, n, all_edges):\n    second_best = None\n    for edge in mst_edges:\n        u, v, t = edge\n        # Create new_edges without this edge\n        new_edges = []\n        for e in all_edges:\n            if e != edge:\n                new_edges.append(e)\n        # Check if new_edges form a connected graph\n        visited = set()\n        queue = [1]\n        while queue:\n            u_node = queue.pop(0)\n            if u_node not in visited:\n                visited.add(u_node)\n                for v_node, t in new_edges:\n                    if v_node not in visited:\n                        queue.append(v_node)\n        if len(visited) == n:\n            # Find the MST of new_edges\n            mst_second = find_mst(new_edges, n)\n            sum_second = sum(t for u, v, t in mst_second)\n            if second_best is None or sum_second < second_best:\n                second_best = sum_second\n    return second_best\n\ndef find_mst_and_second_best(n, m, edges):\n    if m == 0:\n        return (0, 0)\n    \n    # Find the MST\n    all_edges = edges.copy()\n    mst_edges = find_mst(all_edges, n)\n    \n    # Find the second best MST\n    second_best = find_second_best(mst_edges, n, all_edges)\n    \n    return (sum(t for u, v, t in mst_edges), second_best)",
  "tests": "def test_find_mst_and_second_best():\n    # Sample Test Case 1\n    assert find_mst_and_second_best(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 3), (2, 4, 2), (3, 4, 5)]) == (6, 7)\n    \n    # Additional Test Cases\n    assert find_mst_and_second_best(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) == (3, 4)\n    assert find_mst_and_second_best(2, 1, [(1, 2, 1)]) == (1, float('inf')) # There's no second best network possible.\n    \n    # Larger Test Case\n    n = 6\n    edges = [\n        (1, 2, 6), (1, 3, 1), (1, 4, 5), (2, 3, 5), (2, 5, 3), \n        (3, 4, 5), (3, 5, 6), (3, 6, 4), (4, 6, 2), (5, 6, 6)\n    ]\n    assert find_mst_and_second_best(n, len(edges), edges) == (15, 16)"
}