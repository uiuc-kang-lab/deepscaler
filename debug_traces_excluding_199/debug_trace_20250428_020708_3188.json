{
  "data_source": "kodcode",
  "model_code": "import heapq\n\ndef max_unique_cities(N, M, cities, trains):\n    # Sort the cities based on their coordinates\n    cities_sorted = sorted(cities)\n    # Create a dictionary to map each city to its index for quick lookup\n    city_to_index = {city: idx for idx, city in enumerate(cities_sorted)}\n    \n    # Precompute the adjacency list for each city\n    adj = [[] for _ in range(N)]\n    for u, v, d in trains:\n        u_idx = city_to_index[u]\n        v_idx = city_to_index[v]\n        adj[u_idx].append(v_idx)\n        adj[v_idx].append(u_idx)\n    \n    max_count = 1  # At least one city can be visited\n    \n    # Initialize the priority queue with each city as the starting point\n    heap = []\n    for i in range(N):\n        heapq.heappush(heap, (-1, i, float('inf')))\n    \n    # Visited set to track processed (last_distance, current_city) states\n    visited = set()\n    \n    while heap:\n        current_count, current_city, last_distance = heapq.heappop(heap)\n        \n        # If this state has been processed before with a higher count, skip it\n        if current_count < max_count:\n            continue\n        # If this state has been visited with a higher count, skip it\n        if (last_distance, current_city) in visited:\n            continue\n        visited.add((last_distance, current_city))\n        \n        # Update the maximum count found so far\n        if current_count > max_count:\n            max_count = current_count\n        \n        # Explore all connected cities\n        for neighbor in adj[current_city]:\n            distance = abs(cities_sorted[current_city] - cities_sorted[neighbor])\n            new_count = current_count + 1\n            new_last_distance = distance\n            \n            # Check if this new state has been visited with a higher count\n            if (new_last_distance, neighbor) not in visited:\n                heapq.heappush(heap, (-new_count, neighbor, new_last_distance))\n    \n    return max_count",
  "tests": "def test_example_1():\n    N = 4\n    M = 4\n    cities = [1, 3, 6, 10]\n    trains = [(1, 2, 2), (2, 3, 3), (3, 4, 4), (2, 4, 7)]\n    assert max_unique_cities(N, M, cities, trains) == 4\n\ndef test_example_2():\n    N = 3\n    M = 3\n    cities = [2, 5, 8]\n    trains = [(1, 2, 3), (2, 3, 5), (1, 3, 6)]\n    assert max_unique_cities(N, M, cities, trains) == 3\n    \ndef test_no_trains():\n    N = 3\n    M = 0\n    cities = [1, 2, 3]\n    trains = []\n    assert max_unique_cities(N, M, cities, trains) == 1\n\ndef test_disconnected_cities():\n    N = 4\n    M = 3\n    cities = [1, 2, 3, 4]\n    trains = [(1, 2, 1), (2, 3, 2), (3, 4, 3)]\n    assert max_unique_cities(N, M, cities, trains) == 4\n\ndef test_redundant_trains():\n    N = 4\n    M = 5\n    cities = [1, 3, 6, 10]\n    trains = [(1, 2, 2), (2, 3, 3), (3, 4, 4), (1, 3, 5), (2, 4, 7)]\n    assert max_unique_cities(N, M, cities, trains) == 4"
}