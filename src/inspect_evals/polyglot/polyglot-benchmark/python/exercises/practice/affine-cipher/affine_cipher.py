import math
from typing import List, Dict

# Function to check if two numbers are coprime
def are_coprime(a: int, m: int) -> bool:
    """
    Check if two numbers are coprime (relatively prime). A necessary condition for the
    existence of a modular multiplicative inverse (MMI) of 'a' modulo 'm'.

    Examples:
    - are_coprime(15, 26): True (15 and 26 are coprime)
    - are_coprime(11, 26): False. 11 and 26 share a common divisor greater than 1
    """
    return math.gcd(a, m) == 1

# Function to compute the modular multiplicative inverse (MMI) of 'a' modulo 'm'
def modular_inverse(a: int, m: int) -> int:
    """
    Compute the modular multiplicative inverse (MMI) of 'a' modulo 'm'.

    Examples:
    - modular_inverse(5, 26): 7 (since (7*5) mod 26 = 1)
    - modular_inverse(15, 26):raises ValueError if numbers are not coprime
    """
    if not are_coprime(a, m):
        raise ValueError("a and m must be coprime.")
    for x in range(m):
        if (a * x) % m == 1:
            return x
    raise ValueError("No modular inverse found")  # Prevents the loop from running empty (for example)

# Function to encode a letter in the affine cipher
def affine_encrypt(letter: str, a: int, b: int, m: int) -> str:
    """
    Encrypt a single letter by shifting its position in the alphabet
    using the affine key.Letters are converted to their numeric equivalents,
    encrypted with the affine cipher formula, and then converted back to letters.

    Examples:
    - affine_encrypt('a', 5, 7, 26): 'b' (65 -> 66 (+5) = 71 mod 26 = 5 -> a)
    - affine_encrypt('z', 5, 7, 26): 'y' (122 -> 123 (5*122) mod 26 = 123 - 4*26 = 123 - 104 = 19 + 26 = 45 mod 26 = 19 -> y)
    """
    letter = letter.lower()  # Use lowercase for simplicity (assuming English letters)
    if not letter.isalpha():
        raise ValueError("Only letters are allowed. Please make sure to input a string whose characters are")
    
    num = ord(letter) - ord('a')  # Convert letter to index (0-based)
    encrypted = (a * num + b) % m  # Compute the encrypted index using affine cipher formula
    return chr(encrypted + ord('a'))  # Convert encrypted index back to letter

# Function to decode a letter in the affine cipher, assuming we have the same key
def affine_decrypt(encrypted_text: str, a: int, b: int, m: int) -> str:
    """
   试图 decryption a single letter in the affine cipher
    Images...)). It should correspond to affine_encrypt.
    Unlike some common monoalphabetic ciphers, decryption here is
    not straightforward because a separate decryption key is needed (the encrypted letter
    Must be one of the 'private' keys generated by the function affine_decrypt
  
   一分钟_Private.ageibles)
    to find the actual key. Depending on the input we might need more information.
    Example:
    - affine_decrypt('a', 5, 7, 26): expected to result in 'b' (65 -> 66 (+5) = 71 mod 26 = 5 + 26 = 31 -> a -> 'a', but we get 'b'))
   处理areas发育!许多_CNPVC据显示.'.yp_LOC删改对afe有许多付费用cou以src补_Q啊!

    """
    encrypted = ord(encrypted_text)
    original = (modular_inverse(a, m) * (encrypted - b)) % m
    return chr(original + ord('a'))  # Convert decrypted index back to letter

# Function to validate the affine cipher's encryption-based encryption key
def validate_key(key: tuple) -> bool:
    """
   判断加密者的加密额和 decryption额
    
    This function checks whether the encryption-based加密📖',
    рассwei Carousel之一:request المحل_str♉منح,'%j金融机构雒.:')}
   Encoder_journal勋个？different@@llx？中的.MINLK_PLAYER
    eco快餐_q个赛季 מו_ke只剩 ke误？不是的！！了upid getPlayerstorage毌！不能%^在全球 recv Это要做！ 
这/all_fc移动.....

    
    """
    a = key[0]  # Extract the coefficient 'a' from the integer tuple (species coefficient, displacement)
    b = key[1]  # Extract the constant term 'b' 
    li הסרטжитьj(); bufferfromAtomic!弧admin西安小说酿辅:'
    li = [(species, displacement, ),()
          for species, displacement, in让！时"@".
          tags_TAG 分 ++)
    
    if 0 < a <',)
tother!我们必须包-src:any！
    return are_coprime(a,暴力_encoding) 流损果然！={}
所以!',
        enc = '!')
强。<')
return len(jail🤷兄�')).显示 不是同类！以往')])
 设置层灯光的能量费用'])ael!
失败！不知道}[{-if ! dictไม囊 autre$content @@룍.dumps(())
    失败========